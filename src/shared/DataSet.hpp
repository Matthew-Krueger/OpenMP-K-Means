//
// Created by Matthew Krueger on 10/10/25.
//

#ifndef KMEANS_MPI_DATASET_HPP
#define KMEANS_MPI_DATASET_HPP
#include <vector>
#include <random>
#include <optional>
#include <algorithm>
#include <boost/random/normal_distribution.hpp>


#include "Instrumentation.hpp"
#include "Point.hpp"

namespace kmeans {
    class DataSet {
        /**
         * @brief Configuration structure for data set generation.
         *
         * This struct holds various parameters required to generate a synthetic data set
         * suitable for clustering algorithms. It includes details about the distribution
         * of dimensions, total samples, number of dimensions, number of true clusters,
         * cluster spread, and random seed.
         *
         * Contains:
         * clusterDimensionDistributions - vector of low and high values
         * numTotalSamples
         * numDimensions
         * numTrueClusters
         * clusterSpread
         * seed
         */
    public:
        struct Config {
            /**
             * @brief Represents the distribution known centroids for a cluster
             */
            struct ClusterCentroidDimensionDistribution {
                /**
                 * @brief Lower bound for the dimension distribution of a cluster.
                 *
                 * Represents the lower limit of the known centroid. I.e. How low on a dimension a centroid can be placed
                 */
                double low;
                /**
                 * @brief Represents the upper bound for a dimension distribution within a dataset configuration.
                 * Represents the upper limit of the known centroid. I.e. How high on a dimension a centroid can be placed
                 */
                double high;
            };

            /**
             * @brief A vector containing the distribution of dimensions for clusters.
             *
             * This variable stores a collection of `DimensionDistribution` structs that define the range of values (low to high)
             * for each dimension in the clusters. Each element in the vector represents the distribution settings for one dimension.
             */
            std::vector<ClusterCentroidDimensionDistribution> clusterDimensionDistributions;
            /**
             * @brief The total number of samples in the dataset.
             *
             * This variable represents the total count of data points or samples within a dataset.
             */
            size_t numTotalSamples;
            /**
             * Number of dimensions in the dataset.
             *
             * This variable represents the number of dimensions for the points in the dataset. It is used to configure how data is
             * structured and processed in operations related to clustering and dimensionality reduction.
             */
            size_t numDimensions;

            /**
             * @brief The number of clusters to generate
             * If this is not a factor of numTotalSamples, it will distribute to clusters on a round robin basis until exhausted
             */
            size_t numTrueClusters;

            /**
             * @brief Standard deviation for Gaussian noise within blobs.
             * This value controls the spread of points within each cluster generated by the DataSet class.
             */
            double clusterSpread;   // Standard deviation for Gaussian noise within blobs

            /**
            * @brief Seed value used to initialize the random number generator.
            * This seed is critical for reproducibility of results in simulations and datasets generation processes.
            */
            uint64_t seed;
        };

        DataSet() = default;
        explicit DataSet(std::vector<Point> points) : m_Points(std::move(points)) {}
        explicit DataSet(const Config& config);

        inline size_t size() const { return m_Points.size(); }
        inline bool empty() const { return m_Points.empty(); }
        inline const Point& operator[](const size_t index) const { return m_Points[index]; }
        inline std::optional<std::vector<Point>>& getKnownGoodCentroids() { return m_KnownGoodCentroids; }

        inline Point::FlattenedPoints flattenDataset() { return Point::flattenPoints(m_Points); };
        inline static std::vector<Point> unflattenDataset(const Point::FlattenedPoints &flattenedPoints) { return Point::unflattenPoints(flattenedPoints); };

        using iterator = std::vector<Point>::iterator;
        using const_iterator = std::vector<Point>::const_iterator;

        inline iterator begin() { return m_Points.begin(); }
        [[nodiscard]] inline const_iterator begin() const { return m_Points.begin(); }
        inline iterator end() { return m_Points.end(); }
        [[nodiscard]] inline const_iterator end() const { return m_Points.end(); }

        inline const std::vector<Point>& getPoints() const { return m_Points; }

    private:
        inline void reserve(size_t size) { m_Points.reserve(size); }
        inline void emplace_back(const Point &toEmplace) { m_Points.emplace_back(toEmplace); }

        static auto generateCluster(const Point &clusterCenter, size_t numberPoints, double clusterSpread,
                                    std::shared_ptr<std::mt19937> rng);

        std::vector<Point> m_Points;

        // for our 0, we have the known good centroids. We'll just extract and store this so we can use it later, or we might not
        // even use it at all. It's just here since we'll already have it.
        std::optional<std::vector<Point>> m_KnownGoodCentroids = std::nullopt;

        static Point generateSinglePoint(const std::shared_ptr<std::vector<boost::normal_distribution<double>>>& distributions, std::shared_ptr<std::mt19937> rng);


    };
} // kmeans

#endif //KMEANS_MPI_DATASET_HPP